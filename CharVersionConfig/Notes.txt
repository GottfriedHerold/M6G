Setup / Maintenance considerations for CVConfig and managers (with class Manager)

- general: We re-create the whole config after every config change, so hooks are easier.

Normal way:
Manager.__init__ should do minimal setup and make minimal assumptions on validity of passed arguments.
Manager.__init__ is passed both the calling cv_config and a reference to the very set of instructions used to create this manager.
 
Manager.post_setup is then called. With create == NO_CREATE, may assume validity of cv_config, which can be used to
check for the presence of other managers (whose post_setup() may not yet have run).
cv_config's post_process_setup queue can be used to delay running code after all post_setup()'s have run.


(Direct) creation of configs:
Will call Manager.__init__ with cv_config, then Manager.post_setup(with create == create_config)
cv_config's data is assumed completely correct; in particular, the instructions to create manager are included in its
config and data_source_order is setup correctly.
post_setup(create_config) must make sure that database-related setup is run once, if needed.
It may in principle modify/update the cv_configs's python_recipe.
after post_setup(create_config), the manager is not used anymore: We re-create the whole config the normal way.


(Derived) creation of configs from other configs:
We construct and setup the source config and its managers.
The managers on the source are called to construct the target instructions (typically just copy).
Note that the ordering of data source descriptions (and other stuff) is copied identically;
if the set of data sources should change, mark a data source as inactive / make it do nothing rather than
adding / removing, because things get messy otherwise.
We then create the target the normal way using these instruction. The source should NOT be changed.


Adding Managers:
We are given a cv_config whose managers are setup normally.
CVConfig.add_manager(instruction) adds the new instructions and then calls Manager.__init__, followed by Manager.post_setup(add_manager)
Manager.post_setup(create=add_manager) needs to ensure that data_source_descriptions can be read. Other than that,
it basically just needs to take care of the database, as we re-create the manager afterwards anyway.
Note that the cv_config is not in a valid state during post_setup(create=add_manager), as the ordering has not been done.
After that, we restore the ordering and call post_process_setup.
Then we recreate the config from scratch

Deleting Managers:
We are given a cv_config whose managers are setup normally.
We call manager.delete_manager() to inform the manager it is about to be deleted.
Then we remove the instructions and fix the orderings.

Deleting configs:
We re-setup the whole config with calling post_setup(create=delete_config) on all managers rather than post_setup(create=NO_CREATE)
We do *NOT* call manager.delete_manager(), as this is usually not needed: the database will take care of cascade-deleting things.

Change Manager's parameters:
We are given an (old) cv_config whose managers are setup normally.
The manager is informed by a call to Manager.change_instruction(). Then we change the config and recreate all managers.
The calling cv_config assumes that ordering information does not need to be changed and just replaces the instructions.
If that is not the case, Manager.change_instruction() needs to perform additional changes.